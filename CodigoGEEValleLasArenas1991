1991 
  ////// Clasificación Supervisada - Landsat 5 - RF //////

// Centrar el mapa en la zona de estudio
Map.centerObject(Zona, 10);
Map.addLayer(Zona, {color: 'red'}, 'Zona de Estudio');

// Cargar la colección de imágenes de Landsat 5
var dataset1991 = ee.ImageCollection('LANDSAT/LT05/C02/T1_L2')
    .filterDate('1991-01-01', '1991-03-31')
    .filterBounds(Zona)
    .select(['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5']); // Selección de bandas necesarias

// Aplicar el factor de escala y recortar a la zona de estudio
var datasetProcessed1991 = dataset1991.map(function(image) {
  return image.multiply(0.0000275).add(-0.2).clip(Zona)
    .copyProperties(image, ['system:time_start']);
});

// Cargar el DEM y calcular variables topográficas
var dem = ee.Image('USGS/SRTMGL1_003').clip(Zona);
var slope = ee.Terrain.slope(dem).rename('Slope');
var aspect = ee.Terrain.aspect(dem).rename('Aspect');
var texture = dem.reduceNeighborhood({reducer: ee.Reducer.stdDev(), kernel: ee.Kernel.square(3)}).rename('Texture');
var convexity = dem.convolve(ee.Kernel.laplacian8()).rename('Convexity');
var surfaceArea = ee.Image(1).add(slope.pow(2)).sqrt().rename('SurfaceArea');

// TPI y TRI con menor carga computacional
var kernelTPI = ee.Kernel.circle({radius: 250, units: 'meters'}); // Radio más pequeño para optimizar
var meanElev = dem.reduceNeighborhood({reducer: ee.Reducer.mean(), kernel: kernelTPI});
var tpi = dem.subtract(meanElev).rename('TPI');
var tri = dem.reduceNeighborhood({reducer: ee.Reducer.stdDev(), kernel: kernelTPI}).rename('TRI');

// Topographic Wetness Index (TWI)
var filledDem = dem.focalMean(1);
var slopeRad = slope.multiply(Math.PI).divide(180).tan();
var flowAcc = filledDem.multiply(-1).fastDistanceTransform(500).sqrt(); // Menos procesamiento
var twi = flowAcc.divide(slopeRad.add(0.001)).rename('TWI');

// Función para calcular índices espectrales
var addIndices = function(image) {
  var ndvi = image.normalizedDifference(['SR_B4', 'SR_B3']).rename('NDVI');
  var ndwi = image.normalizedDifference(['SR_B2', 'SR_B4']).rename('NDWI');
  var ndsi = image.normalizedDifference(['SR_B2', 'SR_B5']).rename('NDSI');
  var ndgi = image.normalizedDifference(['SR_B2', 'SR_B3']).rename('NDGI');
  var imd = image.normalizedDifference(['SR_B3', 'SR_B1']).rename('IMD');
  var shadow = image.select('SR_B2').lt(0.3).rename('Shadow');

  return image.addBands([ndvi, ndwi, ndsi, ndgi, imd, shadow, slope, aspect, texture, convexity, surfaceArea, tpi, tri, twi]);
};

// Aplicar la función para calcular los índices
var datasetWithIndices1991 = datasetProcessed1991.map(addIndices);
var meanImage1991 = datasetWithIndices1991.mean();

// Datos de entrenamiento y muestreo
var training_data = GlaciarDescubierto.merge(GlaciarCubierto).merge(Morrena)
                    .merge(Agua).merge(AbanicoAluvial).merge(Coluvios)
                    .merge(AfloramientoDeRoca).merge(Llanura);

var training = meanImage1991.sampleRegions({
  collection: training_data,
  properties: ['land_class'],
  scale: 30
});

// Separar los datos en entrenamiento (70%) y prueba (30%)
// **NOTA IMPORTANTE: Esta sección estaba después del entrenamiento y clasificación principal.
// Para una correcta división de los datos de entrenamiento/prueba antes de entrenar
// el clasificador principal y el clasificador de entropía, la he movido aquí.**
var sample = training.randomColumn();
var trainingSet = sample.filter(ee.Filter.lt('random', 0.7));
var testingSet = sample.filter(ee.Filter.gte('random', 0.3));


// Entrenar clasificador RF principal
var classifierRF = ee.Classifier.smileRandomForest(100).train({
  features: trainingSet, // Usar trainingSet aquí
  classProperty: 'land_class',
  inputProperties: meanImage1991.bandNames()
});

// Clasificar la imagen principal
var classifiedRF = meanImage1991.classify(classifierRF);
Map.addLayer(classifiedRF, {min: 1, max: 8, palette: ['#b8c2ef', '#8b92b4', '#40ffcc', '#3665bd', '#e9bb6e', '#ffa500', '#c2534f', '#00b900']}, 'Clasificación RF 1991'); // Cambiado nombre de capa

// Validar Random Forest
var classifiedTestRF = testingSet.classify(classifierRF);
var confusionMatrixRF = classifiedTestRF.errorMatrix('land_class', 'classification');
print('Matriz de confusión RF 1991:', confusionMatrixRF); // Cambiado texto
print('Exactitud general RF 1991:', confusionMatrixRF.accuracy()); // Cambiado texto

// Exportación optimizada
Export.image.toDrive({
  image: classifiedRF,
  description: 'Clasificacion_RF_1991', // Cambiado descripción
  scale: 30,
  region: Zona,
  maxPixels: 1e12,
  folder: 'GEE_Exports',
  fileFormat: 'GeoTIFF'
});

// Obtener la importancia de las variables para el clasificador principal
var variableImportance = classifierRF.explain();

// Extraer los nombres de las variables y sus importancias
var importanceDict = variableImportance.get('importance');
var bandNames = meanImage1991.bandNames();

// Crear un gráfico de importancia de las variables
var chart = ui.Chart.feature.byProperty({
  features: ee.FeatureCollection([ee.Feature(null, importanceDict)]),
  xProperties: bandNames
});

// Configurar el gráfico
chart.setOptions({
  title: 'Importancia de las Variables en el Modelo Random Forest 1991', // Cambiado título
  hAxis: {title: 'Variables'},
  vAxis: {title: 'Importancia'},
  legend: {position: 'none'},
  colors: ['#1f77b4']
});

// Mostrar el gráfico en la consola
print(chart);

// --- INICIO DE LA SECCIÓN DE ENTROPÍA AÑADIDA ---

// Reentrenar clasificador en modo MULTIPROBABILITY para Landsat 5
var clasificadorEntropia1991 = ee.Classifier.smileRandomForest(800) // Mayor número de árboles para estabilidad de probabilidades
    .setOutputMode('MULTIPROBABILITY')
    .train({
      features: trainingSet, // Usar trainingSet
      classProperty: 'land_class',
      inputProperties: meanImage1991.bandNames() // Asegurarse de usar las bandas de Landsat 5
    });

// Clasificación con probabilidades por clase para Landsat 5
var clasificadaProb1991 = meanImage1991.classify(clasificadorEntropia1991);

// Obtener clases únicas para nombrar las bandas de salida
var etiquetasClases = training_data.aggregate_array("land_class").distinct().sort();
var etiquetasClasesList = etiquetasClases.map(function(id){
  return ee.String(ee.Number(id).toInt());
});

// Aplanar arreglo de probabilidades a bandas individuales
var probasPorClase1991 = clasificadaProb1991.arrayFlatten([etiquetasClasesList]);

// Calcular log(probabilidad)
var logProbs1991 = probasPorClase1991.log();

// Calcular entropía: -Σ (p * log(p))
var entropy1991 = probasPorClase1991.multiply(logProbs1991).reduce(ee.Reducer.sum()).multiply(-1).rename('entropy');

// Visualizar en el mapa la entropía para Landsat 5
Map.addLayer(entropy1991, {min: 0, max: 2, palette: ['white', 'yellow', 'red']}, 'Entropía Clasificación RF 1991');

// --- Extraer incertidumbre a los puntos de entrenamiento para Landsat 5 ---
var puntosConEntropia1991 = training_data.map(function(pt) {
  var value = entropy1991.reduceRegion({
    reducer: ee.Reducer.first(),
    geometry: pt.geometry(),
    scale: 30,
    maxPixels: 1e13
  }).get('entropy');

  return pt.set('entropia_1991', value); // Propiedad con sufijo de año para diferenciar
});

print('Puntos con entropía 1991:', puntosConEntropia1991);

// Exportar puntos con entropía a Drive para Landsat 5
Export.table.toDrive({
  collection: puntosConEntropia1991,
  description: 'Puntos_con_Entropia_1991',
  fileNamePrefix: 'Entropia_Puntos_1991',
  fileFormat: 'CSV'
});

// --- FIN DE LA SECCIÓN DE ENTROPÍA AÑADIDA ---


// Función para calcular el área de cada clase en hectáreas (Ya existente en tu código)
var calculateArea = function(classifiedImage, year, classifier) {
  // Añadir el área de píxel (en m²) y la clasificación como bandas
  var areaImage = ee.Image.pixelArea().addBands(classifiedImage.rename('classification'));

  // Reducir por región agrupando por clase
  var areas = areaImage.reduceRegion({
    reducer: ee.Reducer.sum().group({
      groupField: 1, // 'classification' es el segundo (índice 1) en addBands
      groupName: 'class'
    }),
    geometry: Zona,
    scale: 30,
    maxPixels: 1e13
  });

  // Convertir a hectáreas y preparar la salida
  var areaHectares = ee.List(areas.get('groups')).map(function(feature) {
    var dict = ee.Dictionary(feature);
    return dict.set('area_ha', ee.Number(dict.get('sum')).divide(10000));
  });

  print('Área por clase en hectáreas (' + classifier + ' ' + year + '):', areaHectares);
};

// Ejecutar para tu clasificación actual (Random Forest 1991)
calculateArea(classifiedRF, 1991, 'RF');

// La imagen a exportar debe ser convertida a un solo tipo de dato
var imagenFinal = meanImage1991.toFloat();

Export.image.toDrive({
  image: imagenFinal,
  description: 'Imagen_Sat_Landsat5_1991',
  scale: 30,
  region: Zona,
  maxPixels: 1e12,
  folder: 'GEE_Exports',
  fileFormat: 'GeoTIFF'
});
